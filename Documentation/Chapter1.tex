\newpage

\section[Обзор предметной области]{\large \centering Обзор предметной области}
\hspace{\parindent} Выравнивание аминокислотных или нуклеотидных последовательностей --- это процесс сопоставления сравниваемых последовательностей для такого их взаиморасположения, при котором наблюдается максимальное количество совпадений аминокислотных остатков или нуклеотидов~\cite{AlignmentClustal}. Различают два вида выравнивания: парное (выравнивание двух последовательностей ДНК, РНК или белков) и множественное (выравнивание трех и более последовательностей). 

\subsection[Существующие методы поиска гомологий в биологических последовательностях]{\large Существующие методы поиска гомологий в биологических последовательностях} \label{sec:SearchHmlg}
\hspace{\parindent} В генетике под гомологиями понимаются участки белков или ДНК, имеющие сходную последовательность аминокислот или нуклеотидов. Обычно существа, у которых есть гомологичные участки белков или ДНК, имеют общего предка, от которого они и получили такой участок. Поскольку в процессе эволюции ДНК подвергается мутациям, эти участки не обязательно идентичны. В них могут быть случайно заменены, добавлены или удалены нуклеотиды или аминокислоты (рисунок~\ref{ris:Mutation}). Некоторые мутации, такие, как транслокации и инверсии, приводят к изменениям, затрагивающим большие участки генома. Такие мутации сложно учитывать, поскольку локальное сходство проверять легче, чем глобальное, а в результате глобальных мутаций участки ДНК могут быть соединены в непредсказуемом порядке. %Поэтому существующие методы поиска гомологий умеют находить участки (подстроки) двух последовательностей, которые отличаются не очень сильно.

\begin{figure}[h]
	\center{\includegraphics[width=0.45\linewidth]{transform.png}}
	\caption{Пример мутации}
	\label{ris:Mutation}
\end{figure}

\subsubsection[Алгоритм Нидлмана-Вунша]{\large Алгоритм Нидлмана-Вунша} \label{seq:NW}
\hspace{\parindent} Одним из наиболее распространенных алгоритмов выравнивания является алгоритм Нидлмана-Вунша~\cite{NWalgo}, основанный на двумерном динамическом программировании. Для своей работы алгоритм использует матрицу сходства, которая указывает, насколько схожими можно считать разные нуклеотиды. Использование матрицы позволяет придавать разный вес разным заменам нуклеотидов. Например, поскольку транзиции более вероятны, чем трансверсии, логично считать последовательности, отличающиеся заменой пурина на пурин или пиримидина на пиримидин, более схожими, чем те, которые отличаются заменой пурина на пиримидин или наоборот. Обычно используется симметричная матрица, однако, применение несимметричной матрицы позволяет различать замены в одну и в другую стороны. На рисунке~\ref{ris:ReplaceMatrix} представлен пример матрицы сходства. Здесь А, Г, Т и Ц обозначают, соответственно, аденин, гуанин, тимин и цитозин, а числа в матрице указывают степень сходства между двумя нуклеотидами.

\begin{figure}[h]
	\center{\includegraphics[width=0.3\linewidth]{RM.pdf}}
	\caption{Пример матрицы сходства}
	\label{ris:ReplaceMatrix}
\end{figure}

\indent Еще один параметр алгоритма --- штраф за разрыв последовательности. Он может выражаться произвольной функцией от длины и/или направления разрыва. Для определенности будем рассматривать линейный штраф за разрыв, определяющийся параметром $d$ (за разрыв длинны $n$ будет начислен штраф $d \cdot n$).\\
\indent На вход алгоритм получает матрицу сходства $S$, параметр штрафа $d$ и две последовательности (строки), которые необходимо выровнять. Для получения результата выполняется построение матрицы $F_{i,j}$ , где $i$ и $j$ изменяются от нуля до длины, соответственно, первой и второй строк. Вначале алгоритм инициализирует $F_{i,0}$ и $F_{0,j}$ равными, соответственно, $d \cdot i$ и $d \cdot j$ для всех $i$ и $j$. Затем происходит вычисление оставшихся элементов матрицы по формуле~\ref{eq:N_W}.

\begin{equation}\label{eq:N_W}
F_{i,j} = max\left\{
	\begin{aligned}
		& F_{i-1,j-1} + S_{A_i,B_j}\\
		& F_{i-1,j} + d\\
		& F_{i,j-1} + d
	\end{aligned}
	\right.
\end{equation}

\indent  После того, как матрица посчитана, необходимо определить, каким путем появилось значение в правом нижнем углу. Например, если $F_{i,j} = F_{i-1,j-1} +S_{A_{i-1},B_{j-1}}$, то элемент $(i, j)$ появился из элемента $(i - 1, j - 1)$, и т. д. Элементы в верхней строке произошли из элементов левее себя, элементы из левого столбца --- из элементов выше себя. Переход вида $(i, j) \rightarrow (i - 1, j - 1)$ означает, что $i$-му символу в первой строке соответствует $j$-й символ во второй строке. Переход вида $(i, j) \rightarrow (i - 1, j)$ означает, что $i$-му символу первой строки ничего не соответствует, а переход $(i, j) \rightarrow (i, j - 1)$ --- что $j$-му символу второй строки ничего не соответствует. Путь в матрице от левого верхнего угла к правому нижнему даст искомое выравнивание последовательностей.\\
\indent Очевидно, что алгоритм всегда ищет выравнивание с максимальным счетом, так как строя матрицу $F$, он рассматривает всевозможные варианты размещения одной строки относительно другой. Время работы и количество используемой памяти пропорционально произведению длин последовательностей.

\subsubsection[Алгоритм Смита-Ватермана]{\large Алгоритм Смита-Ватермана}
\hspace{\parindent} Алгоритм Смита-Ватермана~\cite{SWalgo} аналогичен алгоритму Нидлмана-Вунша, но решает задачу локального выравнивания: находит подстроки первой и второй строк, обладающие максимальным сходством.\\
\indent На вход алгоритм получает матрицу сходства $S$, две последовательности и два вектора $I$ и $D$, вектор стоимостей добавления и вектор стоимостей удаления, соответственно. Элементы матрицы $F_{i,0}$ и $F_{0,j}$ инициализируются нулями.  Вычисление оставшихся элементов происходит по формуле~\ref{eq:S_W}.

\begin{equation}\label{eq:S_W}
F_{i,j} = max\left\{
	\begin{aligned}
		& F_{i-1,j-1} + S_{A_i,B_j}\\
		& F_{i-1,j} + D_{A_i}\\
		& F_{i,j-1} + I_{B_j}\\
		& 0
	\end{aligned}
	\right.
\end{equation}

\indent Для получения выравнивания необходимо найти максимальный элемент в матрице. Если переходить от этого элемента по цепочке предыдущих, то путь закончится в каком-то нулевом элементе. Индексы этих двух элементов равны индексам начал и концов подстрок: первые индексы --- в первой строке, вторые --- во второй. Путь интерпретируется так же, как и в алгоритме Нидлмана-Вунша.\\
\indent Видно, что оба алгоритма похожи друг на друга. Они имеют одинаковую сложность и затраты по памяти, что делает такие алгоритмы неприемлемыми для работы с большим количеством генетического материала.

\subsubsection[Алгоритм Хиршберга]{\large Алгоритм Хиршберга}
\hspace{\parindent} Оба предыдущих алгоритма требуют объем памяти, пропорциональный произведению длин выравниваемых последовательностей, что затрудняет обработку больших строк, поэтому очень важно иметь методы, уменьшающие затраты памяти без критического увеличения времени счета. В 1975 году был предложен алгоритм Хиршберга, значительно сокращающий затраты памяти~\cite{Hirshberg}. Он позволяет вычислять оптимальное выравнивание строк длины $n$ и $m$, используя $O(n+m)$ количество памяти, но примерно вдвое большее времени счета по сравнению с алгоритмом Нидлмана-Вунша.\\
\indent Идея алгоритма состоит в том, что одна из двух входных последовательностей разбивается на две части, и исходная задача сводится к двум, меньшим, задачам выравнивания второй входной последовательности с каждой из частей. Решение подзадач осуществляется путем аналогичного сведения к подзадачам. На рисунке~\ref{ris:Hirshberg} показана схема разбивки задачи на две подзадачи: верхнюю, которая решается в прямоугольнике $A$ исходной таблицы, и нижнюю --- в прямоугольнике $B$. Последовательности имеют длины $n$ и $m$, соответственно. Для разбиения каждой задачи на подзадачи необходимо вычислить значение $k^*$. При этом используется объем памяти, линейно зависящий от $m$. Верхняя задача заключается в выравнивании строки с длинами не больше $n/2$ и $k^*$, а нижняя – с длинами не больше $n/2$ и $m-k^*$. 

\begin{figure}[h]
	\center{\includegraphics[width=0.6\linewidth]{hirshberg.png}}
	\caption{Разделение задачи выравнивания на две подзадачи}
	\label{ris:Hirshberg}
\end{figure}

\indent Для представления задач в алгоритме Хиршберга можно использовать бинарные деревья~\cite{HirshbergParallel}. Узлам дерева соответствуют подзадачи, которые заключаются в выравнивании меньших подпоследовательностей. Каждый узел дерева хранит в памяти границу прямоугольной области, в которой решается соответствующая задача динамического программирования. Дерево в процессе работы алгоритма строится по уровням. Сначала оно состоит только из корневого узла, который соответствует прямоугольнику $[0,0]\times[n,m]$. Создание двух узлов эквивалентно разбиению задачи на две подзадачи и разделению области решения на две, меньшего размера.\\
\indent Алгоритм Хиршберга заключается в обходе полного дерева всех подзадач. Результат выравнивания можно будет получить, если пройтись по листьям построенного дерева (рисунок~\ref{ris:HirshbergExample}). Для оптимизации вычислений можно выполнять обход (решение подзадач) только части вершин дерева: тех, которые удалены от корня на величину, не превосходящую заранее заданную константу $h$ --- максимальную глубину обхода дерева. При достижении глубины дерева $h$ или минимального размера прямоугольника применяется алгоритм Нидлмана-Вунша, который работает вдвое быстрее алгоритма Хиршберга.

\begin{figure}[h]
	\center{\includegraphics[width=0.6\linewidth]{hirshberg-example.png}}
	\caption{Дерево подзадач для алгоритма Хиршберга}
	\label{ris:HirshbergExample}
\end{figure}

\indent Дополнительное ускорение можно получить за счет распараллеливания. Заметим, что на каждом шаге алгоритма полученные подзадачи никак не связаны между собой, и, следовательно, их решения могут вычисляться в отдельных потоках.

\subsection[Алгоритмы множественного выравнивания]{\large Алгоритмы множественного выравнивания}
\hspace{\parindent} В пункте~\ref{sec:SearchHmlg} были рассмотрены основные подходы для получения парного выравнивания. Для некоторых областей биоинформатики задачу поиска выравнивания необходимо переложить на многомерный случай, например при реконструкции эволюционной последовательности (получение филогенетических деревьев) или при выявлении шаблона функциональных семейств и сигналов ДНК.

\subsubsection[Выравнивание в <<кубе>>]{\large Выравнивание в <<кубе>>}
\hspace{\parindent} Рассмотрим задачу выравнивания трех последовательностей $A_1$, $A_2$ и $A_3$. Построим трехмерную матрицу $F$ (рисунок~\ref{ris:Cube}) с длинами сторон $len(A_i)$, $i = 1,2,3$, где $len(A_i)$ --- длина $i$-ой строки. Аналогично алгоритму Нидлмана-Вунша (пункт~\ref{seq:NW}) определим значение в ячейке $F_{i,j,k}$ $i=1 \ldots len(A_1)$, $j=1 \ldots len(A_2)$, $k=1 \ldots len(A_3)$ по формуле~\ref{eq:CubeAlign}.

\begin{figure}[h]
	\center{\includegraphics[width=0.35\linewidth]{cube.jpg}}
	\caption{Матрица $F$ для выравнивания трех последовательностей}
	\label{ris:Cube}
\end{figure}

\begin{equation}\label{eq:CubeAlign}
F_{i,j} = max\left\{
	\begin{aligned}
		& F_{i-1,j-1,k-1} + S(A_{1_i},A_{2_j}) + S(A_{1_i},A_{3_k}) + S(A_{2_j},A_{3_k})\\
		& F_{i-1,j-1,k} + S(A_{1_i},A_{2_j}) + 2d\\
		& F_{i-1,j,k-1} + S(A_{1_i},A_{3_k}) + 2d\\
		& F_{i,j-1,k-1} + S(A_{2_j},A_{3_k}) + 2d\\
		& F_{i-1,j,k} + 3d\\
		& F_{i,j-1,k} + 3d\\
		& F_{i,j,k-1} + 3d\\
	\end{aligned}
	\right.
\end{equation}

\indent Можно заметить, что каждая грань куба --- это парное выравнивание двух последовательностей с учетом некоторой части третей, что и дает в итоге полный перебор всех возможных вариантов. Нулевые грани куба $F_{0,j,k}$, $F_{i,0,k}$ и $F_{i,j,0}$ заполняются аналогично алгоритму Нидлмана-Вунша.

\indent  Что бы получить ответ необходимо найти путь от ячейки $F_{len(A_1),len(A_2),len(A_3)}$, где записан итоговый счет за выравнивание, до $F_{0,0,0}$. Так как имеется всего семь возможных перемещений в кубе и $len(A_1) \cdot len(A_2) \cdot len(A_3)$ ячеек, то сложность алгоритма можно оценить как $O(7\prod\limits_{i=1}^3len(A_i))$.

\indent Не составляет большого труда <<продлить>> аналогичным образом это решение на $n$-мерный случай и получить <<честное>> многомерное выравнивание. Под словом <<честное>> подразумевается, что рассмотрены все возможные варианты выравнивания последовательностей и полученный результат всегда имеет максимальный счет. Единственный недостаток --- слишком большая вычислительная сложность алгоритма: $O((2^n-1)\prod\limits_{i=1}^nlen(A_i))$, что делает такой подход совершенно неприменимым для выравнивания большого числа и/или длинных последовательностей. 

\subsubsection[Выравнивание выравниваний. Алгоритм Clustal]{\large Выравнивание выравниваний. Алгоритм Clustal}
\hspace{\parindent} Другой подход заключается в в получении парного выравнивания между первыми двумя последовательностями, после чего полученный результат выравнивается с третей и так далее. То есть, если $f$ --- функция вычисления парного выравнивания, а $A_1, \ldots ,A_n$ --- выравниваемые последовательности, то алгоритм можно условно записать формулой~\ref{eq:Closure}.

\begin{equation}\label{eq:Closure}
f(f(f(\ldots f(f(A_1, A_2), A_3) \ldots ), A_{n-1}), A_n)
\end{equation} 

\indent Очевидно, что результат алгоритма будет зависеть от порядка исходных последовательностей. Существуют различные соображения по поводу наиболее правильного выбора этого порядка. Можно не ограничиваться выравниваниями типа <<последовательность против выравнивания>>, но так же производить выравнивание <<выравнивание против выравнивания>>. Например, если есть четыре последовательности, из которых первая очень похожа на четвертую, вторая --- на третью, а гомология между остальными парами (1-2, 1-3, 2-4, 3-4) более слабая, то разумно сначала сделать два парных выравнивания: первой последовательности с четвертой и второй с третей, а затем уже выровнять эти два выравнивания друг с другом.

\indent Похожим образом работает Clustal --- один из самых популярных алгоритмов множественного выравнивания. По сути это жадный алгоритм с <<умным>> способом выбора пар. Сначала происходит построение всех парных выравниваний, после чего по полученным результатам строится <<дерево-подсказка>>. На рисунке~\ref{ris:Clustal} представлен пример возможного дерева. Для четырех последовательностей $A_1, A_2, A_3$ и $A_4$ строится таблица (на рисунке слева) числа в которой обозначают их схожесть друг с другом. Видно, что самые близкие последовательности --- $A_1$ и $A_3$, их выравнивание будет первым, затем оно выравнивается с $A_4$ и в конце с $A_2$.

\begin{figure}[h]
	\center{\includegraphics[width=0.6\linewidth]{Clustal.png}}
	\caption{Построение дерева-подсказки для алгоритма Clustal}
	\label{ris:Clustal}
\end{figure}

\subsection[Выравнивание с учетом открытых рамок считывания]{\large Выравнивание с учетом открытых рамок считывания}
\hspace{\parindent} ЗАГОТОВКА

\subsection[Представление генетической информации в электронном виде]{\large Представление генетической информации в электронном виде}
\hspace{\parindent} Поскольку различных нуклеотидов и стандартных аминокислот немного, для их кодирования используют один символ --- первую букву из названия. С другой стороны, названия многих аминокислот начинаются с одинаковых букв, поэтому для кодирования приходится использовать те, которые остаются незанятыми.

\subsubsection[Формат FASTA]{\large Формат FASTA}
\hspace{\parindent} В формате FASTA~\cite{FASTAformat} строчка, начинающаяся с символа '>', называется строкой описания. Она содержит имя последовательности и некоторую дополнительную информацию, предназначенную для идентификации. Другие строки, начинающиеся с символа ';', являются комментариями и игнорируются. За строкой описания следует код последовательности. При кодировании нуклеотидов буквами A, C, G, T и U кодируют, соответственно, аденин, цитозин, гуанин, тимин и урацил. Обычно, длинные последовательности разбивают на несколько строк длиной не более 80 символов --- это не правило формата, но представление данных таким образом выглядит более наглядно для человека.

\subsubsection[Формат FASTQ]{\large Формат FASTQ}
\hspace{\parindent} FASTQ --- формат представления биологической последовательности совместно с данными о качестве. Он используется для представления данных секвенирования. При кодировании уровней качества используются символы из таблицы ASCII от '!' до '\textasciitilde'.\\
\indent Существует два различных способа выражать уровень качества через вероятность ошибки: формулы~\ref{eq:FASTQ:quality1} и~\ref{eq:FASTQ:quality2}, где $Q$ --- уровень качества, а $p$ --- вероятность, что элемент последовательности ошибочный. При малых значениях $p$ эти способы дают практически идентичные результаты, но с ростом $p$ уровни качества начинают заметно различаются (рисунок~\ref{ris:FASTQscore}).

\begin{equation} \label{eq:FASTQ:quality1}
Q = -10 \cdot \log_{10} p
\end{equation}
\begin{equation} \label{eq:FASTQ:quality2}
Q = -10 \cdot \log_{10} \dfrac{p}{(1-p)}
\end{equation}
\begin{figure}[h]
	\center{\includegraphics[width=0.9\linewidth]{FASTQscore.png}}
	\caption{График уровней качества для формул~\ref{eq:FASTQ:quality1} (красная) и~\ref{eq:FASTQ:quality2} (черная)}
	\label{ris:FASTQscore}
\end{figure}

\indent Файл в формате FASTQ содержит четыре строки для каждой последовательности. Первая строка начинается с символа '@', после которого идет описание последовательности (строка описания). Следующая строка содержит набор символов, кодирующих саму последовательность аналогично формату FASTA. За ней идёт строка, начинающаяся с символа '+', содержащая дополнительное описание последовательности. Последняя строка содержит уровни качества. 

\subsubsection[Формат GenBank]{\large Формат GenBank}
\hspace{\parindent} Запись в формате GenBank состоит из двух секций: секции аннотации и секции данных~\cite{GenBankFormat}. В первой хранится всевозможная информация о последовательности: из какого организма получена, ссылки на другие работы, различные примечания, а во второй --- сама последовательность, аналогично формату FASTA. Начало секции аннотации отмечается кодовым словом <<LOCUS>>, а секция данных начинается со слова <<ORIGIN>>. В конце описания последовательности ставится специальный маркер <<//>>. Формат GenBank, по сравнению с форматами FAST и FASTQ, позволяет представить больше дополнительной информации о последовательности.