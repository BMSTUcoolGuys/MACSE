\newpage

\section[Программная реализация]{\large \centering Программная реализация}
\hspace{\parindent} Разработанный алгоритм реализован на языке программирования C++ без использования сторонних библиотек и может быть запущен на всех основных операционных системах: Windows, Linux, Mac OS. Кроме основного приложения, был создан веб-интерфейс, через который также можно получить выравнивание. Так как задача требует существенных вычислительных ресурсов, практично запускать программу на мощной вычислительной платформе, а осуществлять взаимодействие с ней через веб-интерфейс. Кроме этого, для возможности внедрения отдельных компонент программы в другие проекты, были собраны статические библиотеки построения парного и множественного выравниваний.

\subsection[Структуры данных]{\large Структуры данных}
\hspace{\parindent} Ниже описанны используемые в программе структуры для хранения и обработки данных. Они также входят в состав собранных статических библиотек.

\subsubsection[Представление биологических последовательностей]{\large Представление биологических последовательностей}
\hspace{\parindent} Для представления биологических последовательностей используется структура $BioSeq$ с двумя строковыми полями:
\begin{itemize}
	\item $name$ --- идентификатор последовательности
	\item $nt\_seq$ --- последовательность нуклеотидов
\end{itemize}

Ради удобства использования у нее определен оператор индексирования [ ] и функция $Length$, возвращающая текущую длину последовательности. Чтобы иметь связь нуклеотидного и аминокислотного уровней, реализованы методы, позволяющие получить как трансляцию всей строки по первой рамке считывания, так и конкретного триплета, начинающегося с $i$-го индекса. Также, необходимо иметь возможность вставлять разрывы в последовательность, для чего были добавлены методы $InsertGap(int$ $pos)$ и $InsertGap(int$ $pos,$ $int$ $count)$, добавляющие $1$ или $count$ разрывов по индексу $pos$. Печать реализована через перегруженную операцию $<<$ (листинг~\ref{lst:BioSeqPrint}),
\begin{algorithm}
	\caption{Реализация перегруженной операции вывода $<<$ структуры BioSeq} \label{lst:BioSeqPrint}
	\begin{lstlisting}
friend std::ostream& operator << (std::ostream& stream, 
					const BioSeq& data) {
	stream << data.name << std::endl;
	stream << data.nt_seq << std::endl;
	return stream;
}
	\end{lstlisting}
\end{algorithm}

Это позволяет оформить вывод результата следующим образом: листинг~\ref{lst:BioSeqPrintExample}, однако, в качестве работы программы желательно получить выравнивание не только на нуклеотидном, но также и на аминокислотном уровне. Для наглядного разделения этих двух опций, в структуру были добавлены методы $void$ $PrintNT(std::ostream\&$ $out)$ и $void$ $PrintAA(std::ostream\&$ $out)$, которые выводят результат выравнивания и его трансляцию соответственно в указанный поток $out$.
\begin{algorithm}
	\caption{Вывод результатов выравнивания и их трансляций различными способами} \label{lst:BioSeqPrintExample}
	\begin{lstlisting}
std::vector<BioSeq*> data; 
...
for_each(data.begin(), data.end(), [] (BioSeq* seq) { 
		std::cout << *seq; 
		seq->PrintNT(std::cout);
		seq->PrintAA(std::cout);
	} );
	\end{lstlisting}
\end{algorithm}


\subsubsection[Класс построения парного выравнивания]{\large Класс построения парного выравнивания}
\hspace{\parindent} Вычисление оптимального выравнивания двух последовательностей реализовано через  класс $PairwiseAlign$. Таким образом, в одном объекте собираются и данные, и методы их обработки, что упрощает импорт алгоритма парного выравнивания в другой проект.\\
\indent Класс не содержит полей с исходными последовательностями, в нем хранятся только структуры для построения ответа и параметры выравнивания: штрафы за разрывы, смещение рамки, появление преждевременного стоп-кодона, матрицы замен нуклеотидов и аминокислот. Данные для выравнивания передаются через метод $Align(const$ $BioSeq*$ $s1,$ $const$ $BioSeq*$ $s2)$, реализующий алгоритм из пункта~\ref{PairwiseAlign}. Однако, для увеличения производительности вместо рекурсии происходит заполнение таблицы оптимальных ходов, как в классическом алгоритме Нидлмана-Вунша.

\subsubsection[Профили]{\large Профили}
\hspace{\parindent} Выравненные строки сохраняются в структуру $Profile$. Для экономии памяти и времени в профили заносятся не копии последовательностей, а только указатели на них. Функция объединения записана в виде перегруженной операции $+$ (листинг~\ref{lst:ProfilePlus}).
\begin{algorithm}
	\caption{Определение операций объединения профилей} \label{lst:ProfilePlus}
	\begin{lstlisting}
// alignment of two profiles
Profile& operator + (Profile&);
// alignment of profile and sequence
Profile& operator + (BioSeq*);
	\end{lstlisting}
\end{algorithm}

Кроме этого, профили имеют методы для вычисления оценки за сопоставление двух столбцов нуклеотидов и аминокислот. Также как и для структуры $BioSeq$ реализована возможность вставки разрывов по указанному индексу заданной длины.\\
\indent При работе с профилями необходимо гарантировать, что ни одна из входящих в его состав последовательностей не будет модифицирована или удалена до конца построения выравнивания. В противном случае, возможно появление ошибок выполнения или ухудшение качества результата. 

\subsection[Общая схема работы]{\large Общая схема работы}
\hspace{\parindent} Все разбито на отдельные блоки-этапы, блок-схема

\subsubsection[Чтение входных данных]{\large Чтение входных данных}
\hspace{\parindent} Формат входных данных, FASTA и че еще есть
как пиздато одним шмотком память выделяется
листинг с примерами, чтение FASTA

\subsubsection[Определение порядка выравниваний]{\large Определение порядка выравниваний}
\hspace{\parindent} Экономия памяти, нет перевыделения строк

\subsubsection[Объединение профилей]{\large Объединение профилей}
\hspace{\parindent} Пиздатый плюсик

\subsection[Параметры выравнивания]{\large Параметры выравнивания}
\hspace{\parindent} 

\subsection[Руководство пользователя]{\large Руководство пользователя}
\hspace{\parindent} графический интерфейс консолька